<!DOCTYPE html> 
<meta charset="utf-8">
<style>
  
.chart rect {                                                                 
    stroke-opacity: 0;
    fill-opacity: 0.5;
}


.menu_container rect {
    fill-opacity: 0; 
}

body {
    font: 5px Helvetica Neue;
    text-rendering: optimizeLegibility;
    margin-top: 1em;
    overflow-y: scroll;
}

#piechart {
    fill: #ffffff;
    stroke: gray;
    font-face: sans-serif;
    font-size 10px; 
    height: 300px;
    width: 450px;
}
#piechart .total{
    font-size: 18px;
    font-weight: bold;
}
#piechart .units{
    fill: gray;
    font-size: 12px;
}
#piechart .label{
    fill: #CCC;
    font-size: 12px;
    font-weight: bold;
}
#piechart .value{
    font-size: 12px;
    font-weight: bold;
}

</style> 
<body> 
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/prototype/1.7.1.0/prototype.js"></script>
  <script>
    var $j = jQuery.noConflict()
$j( document ).ready(function () {                                               
    console.log( "document loaded" )
    var JSON
    var JSON_vals  
    (function () {
        var callback = function () {
            JSON = (function () {
                var json = null
                $j.ajax({
                    'async': false,
                    'global': false,
                    'url': 'json.txt',
                    'dataType': "json",
                    'success': function (data) {
                        json = data
                    }
                })
                return json
            })()
            JSON_vals = Object.values(JSON)
        }
        callback()
        setInterval(callback, 30000) 
    })()

    console.log(JSON["Sullivan"]) 
    var menu_strs = Object.keys(JSON)  // strings for txt of initial menu 
    
    var chart = d3.select("body")
        .append("svg:svg")                      
        .attr("class", "chart")
    

//////////////////////////////////////////////////////////////////////////////////
//// MENU CONSTRUCTOR ////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////

    var cush = 1.10
    var menu_x = 0
    var menu_y = 0 
    
    var menu_back = container.append("rect")
        .attr("class", menu_back_class)
        .attr("x", menu_x) 
        .attr("y", menu_y)
    
    var menu_container = container.append("svg:svg")
        .attr("class", menu_container_class) 
        .attr("x", menu_x)
        .attr("y", menu_y)
            
    var text = menu_container.selectAll("text")
        .data(menu_strs)
        .enter().append("text")
        .attr("class", "menu_txt" )
        .text(String)
    
    var bars = menu_container.selectAll("rect")
        .data(JSON_vals)
        .enter().append("rect")
        .attr("class", "menu_bars" )


    // align text and bars horizontally
    // bool is passed to signal if the 
    // bars should lined up from 
    // left (true == 1) or right (false == 0)  
    function align(bar_class, txt_class, x_0, y_0, bool) {
        
        var menu_width = 0
        var pos = x_0
        var f_minus = function (x, y) {
            return x - y
        }
        var f_plus = function (x, y) {
            return x + y 
        } 
        var oper = f_plus
        if (bool) {
            oper = f_minus 
        }
        var txt_selection = $j( "." + txt_class )
        if (bool) {
            txt_selection = $($j( "." + txt_class ).get().reverse()) 
        }
        
        txt_selection.each( function (i, el) {
            var bbox = el.getBBox()
            var width = cush * bbox.width  
            var height = cush * bbox.height
            $j(el).attr("x", pos )
                .attr("y", y_0 + .75 * height ) 
            $j("." + bar_class ).eq(i)
                .attr("width", width )
                .attr("height", height )
                .attr("x", pos )
                .attr("y", menu_y)                

            menu_width += width
            pos = oper(pos, width)
            
        });
        
        return menu_width
        
    }              

    var menu_width = align("menu_bars", "menu_txt", menu_x, menu_y, false)   
    var menu_height = $j(".menu_bars").attr("height")          
    
    menu_back.attr( "height", menu_height )
        .attr("width", menu_width ) 


//////////////////////////////////////////////////////////////////////////////////
    
    var dropdown_container = chart.append("svg:svg")
        .attr("class", "dropdown_container")
        .attr("x", menu_x) 
        .attr("y", menu_y + menu_height) 

    var time_updated 
    var dropdown_bars 
    var dropdown_txt 

    // event handler for dropdown menus 
    $j(".menu_bars").on('mouseenter', function (event) {
        
        // d3 data stored at node
        var data_obj = d3.select(event.target).data()[0]              
        var keys = $j.grep( Object.keys(data_obj), function (s, i) {  
            return s !== "time"  
        })
        var data = Object.values(data_obj).sort()
        
        // pulling out time property value out of sorted array of data  
        time_updated = data.splice(0, 1)[0] 
        
        // joining new data with old data
        dropdown_bars = dropdown_container.selectAll("rect")          
            .data(data)

        // this is the update selection
        dropdown_bars.attr("class", "update")

        // enter in new nodes and name enter class
        dropdown_bars.enter().append("rect") 
            .attr("class", "enter")

        // tranisiton out old bars 
        dropdown_bars.exit().remove() 

        dropdown_txt = dropdown_container.selectAll("text")
            .data(keys)
        
        dropdown_txt.attr("class", "update")
        
        dropdown_txt.enter().append("text") 
            .attr("class", "enter")
        
        dropdown_txt.exit().remove() 

        current_text = $(".dropdown_container .update")

        var curr_width

        current_text.each( function (i, el) {
            var width = el.getBBox().width
            curr_width += width
        });

        var scale_width = .75 * (menu_width / cush)
        var scale_factor = scale_width / curr_width 

        current_text.attr("transform", scale(scale_factor) )

        var this_x = $j(event.target).attr("x")
        var flag = (this_x + scale_width) > (menu_x + menu_width)

        var x_drop = this_x
        if (flag) {
            
            x_drop = menu_x + menu_width

        }
        
        align(".dropdown_container text", ".dropdown_container rect", 
              x_drop, menu_y + menu_width, flag)

    })

        
    ///////////////////////////////////////////////////////////////////////////////
    //// PIECHART CODE MODIFIED FROM D3 TUTORIAL //////////////////////////////////
    //// BY STEPHEN BOAK //////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    
    var w = 450;
    var h = 300;
    var r = 100;
    var ir = 45;
    var textOffset = 14;
    var tweenDuration = 250;
    
    //OBJECTS TO BE POPULATED WITH DATA LATER
    var valueLabels
    var pieData = [];    
    var oldPieData = [];
    var filteredPieData = [];

    //D3 helper function to draw arcs, populates parameter "d" in path
    //object
    var arc = d3.svg.arc()
        .startAngle(function(d){ return d.startAngle; })
        .endAngle(function(d){ return d.endAngle; })
        .innerRadius(ir)
        .outerRadius(r);
    
    ///////////////////////////////////////////////////////////
    // CREATE VIS & GROUPS ////////////////////////////////////
    ///////////////////////////////////////////////////////////

    var vis = chart.append("svg:svg")
        .attr("id", "piechart")
        .attr("x", )
        .attr("y", )  
   
    //PLACEHOLDER GRAY CIRCLE
    var paths = arc_group.append("svg:circle")
        .attr("fill", "#EFEFEF")
        .attr("r", r);

    //HANDLER FOR GRAY CIRCLE
    $j(":not(.dropdown_container *):not(#piechart):not(#piechart *)")
        .on("mouseenter", function (event) {

            arc_group.selectAll("circle").remove();
            arc_group.append("svg:circle")
                .attr("fill", "#EFEFEF")
                .attr("r", r);

        })

    //GROUP FOR ARCS/PATHS
    var arc_group = vis.append("svg:g")
        .attr("class", "arc")
        .attr("transform", "translate(" + (w/2) + "," + (h/2) + ")");

    //GROUP FOR LABELS
    var label_group = vis.append("svg:g")
        .attr("class", "label_group")
        .attr("transform", "translate(" + (w/2) + "," + (h/2) + ")");

    //GROUP FOR CENTER TEXT  
    var center_group = vis.append("svg:g")
        .attr("class", "center_group")
        .attr("transform", "translate(" + (w/2) + "," + (h/2) + ")");

    ///////////////////////////////////////////////////////////
    // CENTER TEXT ////////////////////////////////////////////
    ///////////////////////////////////////////////////////////

    //WHITE CIRCLE BEHIND LABELS
    var whiteCircle = center_group.append("svg:circle")
        .attr("fill", "white")
        .attr("r", ir);

    // "TOTAL" LABEL
    var totalLabel = center_group.append("svg:text")
        .attr("class", "label")
        .attr("dy", -15)
        .attr("text-anchor", "middle") // text-align: right
        .text("TOTAL");

    //TOTAL TRAFFIC VALUE
    var totalValue = center_group.append("svg:text")
        .attr("class", "total")
        .attr("dy", 7)
        .attr("text-anchor", "middle") // text-align: right
        .text("Waiting...");

    //UNITS LABEL
    var totalUnits = center_group.append("svg:text")
        .attr("class", "units")
        .attr("dy", 21)
        .attr("text-anchor", "middle") // text-align: right


    ///////////////////////////////////////////////////////////
    // MOUSEENTER HANDLER  /////////////////////////////////////
    ///////////////////////////////////////////////////////////

    // event handler for when status attribute is moused over 
    function update(event) {
                
        var data = d3.select(event.target).data

        var value = Number(data.value)
        var empty_slice = Number(data.max_val) - value 
        
        var values = [ value, empty_slice ]

        pieData  = d3.layout.pie(values)
        oldPieData = filteredPieData;
                
        var totalOctets = Number(data.max_val)

        filteredPieData = pieData.filter(filterData);
        function filterData(element, index, array) {
            element.value = values[index];
            return (element.value > 0);
        }
        
        if(filteredPieData.length > 0 && oldPieData.length > 0){

            arc_group.selectAll("circle").remove();
            totalUnits.text(data.unit)
           
            totalValue.text(function(){
                var value = totalOctets
                return value.toFixed(1);
            });
            
            //DRAW ARC PATHS
            paths = arc_group.selectAll("path").data(filteredPieData);
            paths.enter().append("svg:path")
                .attr("stroke", "white")
                .attr("stroke-width", 0.5)
                .attr("fill", function(d, i) { return color(i); })
                .transition()
                .duration(tweenDuration)
                .attrTween("d", pieTween);
            paths
                .transition()
                .duration(tweenDuration)
                .attrTween("d", pieTween);
            paths.exit()
                .transition()
                .duration(tweenDuration)
                .attrTween("d", removePieTween)
                .remove();
            
            //DRAW LABELS WITH PERCENTAGE VALUES
            valueLabels = label_group.selectAll("text.value").data(filteredPieData)
                .attr("dy", function(d){
                    if ((d.startAngle+d.endAngle)/2 > Math.PI/2 && (d.startAngle+d.endAngle)/2 < Math.PI*1.5 ) {
                        return 5;
                    } else {
                        return -7;
                    }
                })
                .attr("text-anchor", function(d){
                    if ( (d.startAngle+d.endAngle)/2 < Math.PI ){
                        return "beginning";
                    } else {
                        return "end";
                    }
                })
                .text(function(d){
                    var percentage = (d.value/totalOctets)*100;
                    return percentage.toFixed(1) + "%";
                });
            
            valueLabels.enter().append("svg:text")
                .attr("class", "value")
                .attr("transform", function(d) {
                    return "translate(" + Math.cos(((d.startAngle+d.endAngle - Math.PI)/2)) * (r+textOffset) + "," + Math.sin((d.startAngle+d.endAngle - Math.PI)/2) * (r+textOffset) + ")";
                })
                .attr("dy", function(d){
                    if ((d.startAngle+d.endAngle)/2 > Math.PI/2 && (d.startAngle+d.endAngle)/2 < Math.PI*1.5 ) {
                        return 5;
                    } else {
                        return -7;
                    }
                })
                .attr("text-anchor", function(d){
                    if ( (d.startAngle+d.endAngle)/2 < Math.PI ){
                        return "beginning";
                    } else {
                        return "end";
                    }
                }).text(function(d){
                    var percentage = (d.value/totalOctets)*100;
                    return percentage.toFixed(1) + "%";
                });
            
            valueLabels.transition().duration(tweenDuration).attrTween("transform", textTween);
            
            valueLabels.exit().remove();
            
        }
    }

    ///////////////////////////////////////////////////////////
    // FUNCTIONS //////////////////////////////////////////////
    ///////////////////////////////////////////////////////////

    // Interpolate the arcs in data space.
    function pieTween(d, i) {
        var s0;
        var e0;
        if(oldPieData[i]){
            s0 = oldPieData[i].startAngle;
            e0 = oldPieData[i].endAngle;
        } else if (!(oldPieData[i]) && oldPieData[i-1]) {
            s0 = oldPieData[i-1].endAngle;
            e0 = oldPieData[i-1].endAngle;
        } else if(!(oldPieData[i-1]) && oldPieData.length > 0){
            s0 = oldPieData[oldPieData.length-1].endAngle;
            e0 = oldPieData[oldPieData.length-1].endAngle;
        } else {
            s0 = 0;
            e0 = 0;
        }
        var i = d3.interpolate({startAngle: s0, endAngle: e0}, {startAngle: d.startAngle, endAngle: d.endAngle});
        return function(t) {
            var b = i(t);
            return arc(b);
        };
    }

    function removePieTween(d, i) {
        s0 = 2 * Math.PI;
        e0 = 2 * Math.PI;
        var i = d3.interpolate({startAngle: d.startAngle, endAngle: d.endAngle}, {startAngle: s0, endAngle: e0});
        return function(t) {
            var b = i(t);
            return arc(b);
        };
    }

    function textTween(d, i) {
        var a;
        if(oldPieData[i]){
            a = (oldPieData[i].startAngle + oldPieData[i].endAngle -
                 Math.PI)/2;
        } else if (!(oldPieData[i]) && oldPieData[i-1]) {
            a = (oldPieData[i-1].startAngle + oldPieData[i-1].endAngle -
                 Math.PI)/2;
        } else if(!(oldPieData[i-1]) && oldPieData.length > 0) {
            a = (oldPieData[oldPieData.length-1].startAngle +
                 oldPieData[oldPieData.length-1].endAngle - Math.PI)/2;
        } else {
            a = 0;
        }
        var b = (d.startAngle + d.endAngle - Math.PI)/2;

        var fn = d3.interpolateNumber(a, b);
        return function(t) {
            var val = fn(t);
            return "translate(" + Math.cos(val) * (r+textOffset) + "," +
                Math.sin(val) * (r+textOffset) + ")";
        };
    }

})


</script> 

